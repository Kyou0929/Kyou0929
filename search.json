[{"title":"浅谈HashMap插入","date":"2022-03-14T13:30:00.000Z","url":"/2022/03/14/hashmap/","tags":[["JAVA","/tags/JAVA/"],["源码","/tags/%E6%BA%90%E7%A0%81/"]],"categories":[["抠脚技术文","/categories/%E6%8A%A0%E8%84%9A%E6%8A%80%E6%9C%AF%E6%96%87/"]],"content":"HashMap的特点在进入主题之前，我们先来聊聊HashMap的特点： 支持key-value。在编程中映射是一个十分重要的概念，哪怕平平无奇的Object obj = new Object()语句，也是建立在映射这一概念之上。 接近O(1)的时间复杂度。HashMap的底层是数组+链表&#x2F;红黑树的结构，在数据量不大的情况下，能达到O(1)的时间复杂度，可以说是仅此于数组的存在了。 既然我们了解了HashMap的独特之处，那么我们来聊聊到底如何实现HashMap。 HashMap结构首先我们来看看HashMap的一个结构： 由图我们可以看出，HashMap的核心是一个数组，所有的存入元素都和数组进行一次hash运算（例子中采用元素大小和数组长度取模的方式），进而计算出在数组中所存的位置（索引），当出现hash冲突时候（取模出现相同，例子中5%8 &#x3D; 5，13%8 &#x3D; 5）这时候就采用链表将重复的元素进行链接。可见，HashMap的原理并不复杂，仅仅只是一个哈希存储而已。 HashMap的源码上面讲了HashMap的原理，接着我们通过来分析HashMap的源码来看看JAVA是怎么实现上述操作。 在HashMap中最核心的就是Node类，这是HashMap的内部类，底层的数组中每一个元素便是它，名为桶（bin），它实现了Map接口中的Entry接口。下面是Node的部分源码，值得注意的是hash和key这两个变量都用final修饰。 接下来我们将通过对源码的分析来观察HashMap如何对值进行存储和读取。在这之前，我们先看一下HashMap的静态成员，这里主要介绍HashMap的一些默认属性。 在介绍完HashMap的属性后，来看看HashMap的变量，注意这些变量都用transient关键字描述，表示不会被序列化。 在上面，我们已经对HashMap的基本变量和常量有所了解了，接下来，我们将会去进一步了解HashMap最核心的put(K key, V value)方法。当然，在这之前我们先看看HashMap是怎么计算哈希值的。 可以看出，java计算hash的方法十分简单，将对象的hashcode与其最高的16位进行异或运算。在讲解为什么要这样做之前，先说说HashMap是怎么寻找数组的下标的 从上面的代码可以看到，数组的index是由哈希值与上数组的长度 - 1得来。先讲解一下为什么是(n-1)，因为数组的长度永远都是2的次方，这就意味着，n-1可以得到一个低位掩码（全为1）。举个例子 当数组的长度比较小（hashmap刚开始初始化的时候数组长度仅为8，哪怕经过多次扩容，也仍是非常小），index的高位永远都是0，而低位则有所变化，最终取这个结果作为索引值。 再回过头来看上面的hash，你会发现一个问题，如果不将hashcode右移16位进行异或运算，这样会造成，当hashmap容量较小的时候，hashcode的高位无法参与运算，若多个对象仅在hashcode的高位有所不同，这将造成大量的冲突。因此我们对hashcode与其自身的高16位进行异或运算，让高位也参与进来以减少冲突的产生。由此得出，int hash(Object key)这个方法是作为一个扰动函数的存在以降低hash的冲突。 put(K key, V value)： 说实在，很难不吐槽这个put方法，极其明显的C语言风格。 这里讲讲扩容方法 总结从这次的源码阅读来看，其实hashmap是一个非常有意思的类，其中包含着许多数学知识（如负载因子的泊松分布）和数据结构的知识（红黑树），但因为篇幅有限（懒得读了）这里就不做深入了解了。"}]